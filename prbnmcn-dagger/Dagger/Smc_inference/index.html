<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Smc_inference (prbnmcn-dagger.Dagger.Smc_inference)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">prbnmcn-dagger</a> &#x00BB; <a href="../index.html">Dagger</a> &#x00BB; Smc_inference</nav><header class="odoc-preamble"><h1>Module <code><span>Dagger.Smc_inference</span></code></h1><p>Sequential Monte Carlo</p><p>Sequential Monte Carlo (SMC) represents a probability distribution by a family of particles weighted by their scores (the <em>population</em> in SMC parlance). The population is evolved by alternating importance sampling steps and resampling steps. The goal of resampling steps is to increase the statistical quality of the population, e.g. by removing zero or low-score particles and &quot;reproducing&quot; high-score ones.</p><p>At any point, one can obtain an approximation of the target distribution by normalizing the scores of the population.</p><p>Resampling steps must be <em>unbiased</em>: the resampled population must represent the same target distribution as the population before resampling. See <a href="../Resampling/index.html"><code>Resampling</code></a> for the API related to resampling strategies.</p><p>This module provides a convenient API for describing models to be run with SMC inference. It lets the user write the importance sampling part of the model and the resampling strategy modularly. Resampling points are marked using the <a href="module-type-S/index.html#val-yield">yield</a> primitive, which also acts as a message-passing bridge between each importance sampling step and the resampling step that follows it:</p><pre class="language-ocaml"><code>val yield : particle_output -&gt; resampling_state t</code></pre><p>In a nutshell:</p><ul><li>particles give their current value as argument to <a href="module-type-S/index.html#val-yield">yield</a>, and the outcome of resampling (of type <code>resampling_state</code>) is broadcast to each particle as the value to which <a href="module-type-S/index.html#val-yield">yield</a> evaluates to.</li><li><a href="../Resampling/index.html#type-strategy">Resampling steps</a> take the outcome of the previous resampling step as argument.</li></ul><p>Note: applications that do not require to maintain state across resampling steps can set <code>resampling_state = unit</code>. Non-trivial resampling states are mostly useful for programming advanced SMC constructs.</p><p>The flow of data is subsumed in the following diagram:</p> <img src="http://stengah.free.fr/assets/dagger/smc-diagram.png" style="width:200mm;" /> <p>From an implementation perspective, SMC inference proceeds by letting particles, implemented as lightweight threads, evolve independently until the next resampling event. Resampling acts as a synchronization barrier for all particles. The output of the inference is a sequence of the scored values carried by the particles just before each resampling.</p><p>Have a look at the <a href="../../smc_inference_example.html">examples</a>.</p></header><nav class="odoc-toc"><ul><li><a href="#api-of-sequential-monte-carlo-inference">API of sequential Monte Carlo inference</a></li><li><a href="#predefined-instances-of-make">Predefined instances of <code>Make</code></a></li><li><a href="#predefined-resampling-strategies">Predefined resampling strategies</a></li></ul></nav><div class="odoc-content"><h3 id="api-of-sequential-monte-carlo-inference"><a href="#api-of-sequential-monte-carlo-inference" class="anchor"></a>API of sequential Monte Carlo inference</h3><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The sequential Monte Carlo DSL.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Resampling_types_S"><a href="#module-type-Resampling_types_S" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Resampling_types_S/index.html">Resampling_types_S</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The SMC implementation is parametric in the type of values produced by the particles at each <a href="module-type-S/index.html#val-yield">yield</a> and in the type of state of resampling.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Make/index.html">Make</a></span><span>
  (<a href="Make/argument-1-Resampling_types/index.html">Resampling_types</a> : <a href="module-type-Resampling_types_S/index.html">Resampling_types_S</a>) : 
  <a href="module-type-S/index.html">S</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-particle_output">particle_output</a> = <a href="Make/argument-1-Resampling_types/index.html#type-particle_output">Resampling_types.particle_output</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-resampling_state">resampling_state</a> = <a href="Make/argument-1-Resampling_types/index.html#type-resampling_state">Resampling_types.resampling_state</a></span></span></code></div><div class="spec-doc"><p><code>Make</code> produces an SMC inference module specialized to the types given in <code>Resampling_types</code>.</p></div></div><h3 id="predefined-instances-of-make"><a href="#predefined-instances-of-make" class="anchor"></a>Predefined instances of <code>Make</code></h3><div class="odoc-spec"><div class="spec module anchored" id="module-Unit_smc"><a href="#module-Unit_smc" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Unit_smc/index.html">Unit_smc</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Float_smc"><a href="#module-Float_smc" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Float_smc/index.html">Float_smc</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="predefined-resampling-strategies"><a href="#predefined-resampling-strategies" class="anchor"></a>Predefined resampling strategies</h3><div class="odoc-spec"><div class="spec value anchored" id="val-systematic_resampling"><a href="#val-systematic_resampling" class="anchor"></a><code><span><span class="keyword">val</span> systematic_resampling : 
  <span>ess_threshold:float <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'o</span>, float, <span class="type-var">'s</span>)</span> <a href="../Resampling/index.html#type-strategy">Resampling.strategy</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stratified_resampling"><a href="#val-stratified_resampling" class="anchor"></a><code><span><span class="keyword">val</span> stratified_resampling : 
  <span>ess_threshold:float <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'o</span>, float, <span class="type-var">'s</span>)</span> <a href="../Resampling/index.html#type-strategy">Resampling.strategy</a></span></span></code></div></div></div></body></html>