<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Resampling (prbnmcn-dagger.Dagger.Resampling)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">prbnmcn-dagger</a> &#x00BB; <a href="../index.html">Dagger</a> &#x00BB; Resampling</nav><header class="odoc-preamble"><h1>Module <code><span>Dagger.Resampling</span></code></h1><p>Resampling functions.</p><p>Resampling is used to improve the statistical quality of a population of weighted particles.</p><p>Informally, resampling consists in sampling <code>N</code> new particles (each with weight <code>1/N</code>) from a given population such that the resulting population is distributed identically to the target one (ie is unbiased).</p><p>An straightforward to proceed would be to sample from a multinomial distribution with parameters <code>N</code> and the normalized weights of the given population. Other schemes are used in practice.</p><p>We consider the following schemes:</p><ul><li>systematic resampling</li><li>stratified resampling</li></ul><p>In the following, we consider an (ordered, even if arbitrarily) family of particles <code>(x_k, w_k)</code> for <code>k=1...K</code>.</p><p>The outcome of resampling is a map from each particle <code>x_k</code> to a replication count <code>r_k</code>.</p></header><nav class="odoc-toc"><ul><li><a href="#systematic-resampling">Systematic resampling</a></li><li><a href="#stratified-resampling">Stratified resampling</a></li><li><a href="#references">References</a></li></ul></nav><div class="odoc-content"><h3 id="systematic-resampling"><a href="#systematic-resampling" class="anchor"></a>Systematic resampling</h3><p>Let <code>U</code> be sampled uniformly in <code>[0,1/N]</code>. Consider the partition of the <code>[0,1)</code> interval in <code>N</code> sub-intervals given by the points <code>U_i = U + (i-1)/N</code> for <code>i=1...N-1</code>.</p><p>Associate to each particle <code>x_k</code> its cumulative weight <code>W_k = w_1 + ... + w_k</code> and let us set <code>W_0 = 0</code>.</p><p>We set <code>r_k</code> to be the cardinal of the set of <code>U_i</code> included in <code>[W_{k-1}, W_k]</code>.</p><h3 id="stratified-resampling"><a href="#stratified-resampling" class="anchor"></a>Stratified resampling</h3><p>For each <code>i</code> in <code>1...N</code>, let <code>U_i</code> be sampled uniformly in <code>[0, 1/N]</code> and consider the family of intervals <code>(i-1)/N, (i-1)/N + U_i</code> for <code>i=1...N</code>. We associate to each <code>i</code> the particle <code>x_k</code> with the lowest <code>k</code> such that <code>W_k</code> verifies <code>(i-1)/N + U_i &lt; W_k</code>.</p><p>The replication count <code>r_k</code> is the number of times <code>x_k</code> was selected in this process.</p><h3 id="references"><a href="#references" class="anchor"></a>References</h3><p>A Tutorial on Particle Filtering and Smoothing: Fifteen years lated (Doucet &amp; Johansen)</p><div class="odoc-spec"><div class="spec module-type" id="module-type-Particle" class="anchored"><a href="#module-type-Particle" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Particle/index.html">Particle</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A <code>Particle</code> is any abstract type from which a <code>weight</code> can be computed.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-S" class="anchored"><a href="#module-type-S" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The module type exposing resampling functions.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Make" class="anchored"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Make/index.html">Make</a></span><span>
  (<a href="Make/argument-1-F/index.html">F</a> : <a href="../Intf/module-type-Field/index.html">Intf.Field</a>)
  (<a href="Make/argument-2-P/index.html">P</a> : <a href="module-type-Particle/index.html">Particle</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-Particle/index.html#type-field">field</a> = <a href="Make/argument-1-F/index.html#type-t">F.t</a></span>)
  (<a href="Make/argument-3-Sampler/index.html">Sampler</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : 
  <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-field">field</a> = <a href="Make/argument-1-F/index.html#type-t">F.t</a></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-particle">particle</a> = <a href="Make/argument-2-P/index.html#type-t">P.t</a></span></span></code></div><div class="spec-doc"><p>The <code>Make</code> functor is generic over a field <code>F</code> and a uniform sampler. Genericity over the underlying field is especially useful for testing, using arbitrary-precision rationals.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Float_field" class="anchored"><a href="#module-Float_field" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Float_field/index.html">Float_field</a></span><span> : <a href="../Intf/module-type-Field/index.html">Intf.Field</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Intf/module-type-Field/index.html#type-t">t</a> = float</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Make_float" class="anchored"><a href="#module-Make_float" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Make_float/index.html">Make_float</a></span><span>
  (<a href="Make_float/argument-1-P/index.html">P</a> : <a href="module-type-Particle/index.html">Particle</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-Particle/index.html#type-field">field</a> = float</span>) : 
  <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-field">field</a> = float</span> <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-particle">particle</a> = <a href="Make_float/argument-1-P/index.html#type-t">P.t</a></span></span></code></div><div class="spec-doc"><p><code>Make_float</code> instantiates <a href="Make/index.html"><code>Make</code></a> over the field of floats.</p></div></div></div></body></html>